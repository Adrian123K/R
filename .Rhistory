rs
for (i in 1:nrow(raw)){
temp <- sqrt(sum((raw[i,]-center[j,])^2))
rs$d1[i] <- temp
rs
for (i in 1:nrow(raw)){
temp <- sqrt(sum((raw[i,]-center[j,])^2))
rs$d1[i] <- temp
}
rs
for (i in 1:nrow(raw)){
d <- sqrt(sum((raw[i,]-center[j,])^2))
rs$d1[i] <- d
}
rs
for (i in 1:nrow(raw)){
d <- sqrt(sum((raw[i,]-center[j,])^2))
rs$d1[i] <- d
}
rs$rank <- rank(rs$d1,ties.method = 'min')
rs
for (i in 1:nrow(raw)){
d <- sqrt(sum((raw[i,]-center[j,])^2))
rs$d1[i] <- d
}
rs$rank <- dense_rank(rs$d1,ties.method = 'min')
library(doBy)
for (i in 1:nrow(raw)){
d <- sqrt(sum((raw[i,]-center[j,])^2))
rs$d1[i] <- d
}
rs$rank <- dense_rank(rs$d1,ties.method = 'min')
library(dplyr)
for (i in 1:nrow(raw)){
d <- sqrt(sum((raw[i,]-center[j,])^2))
rs$d1[i] <- d
}
rs$rank <- dense_rank(rs$d1,ties.method = 'min')
for (i in 1:nrow(raw)){
d <- sqrt(sum((raw[i,]-center[j,])^2))
rs$d1[i] <- d
}
rs$rank <- dense_rank(rs$d1)
rs
for (i in 1:nrow(raw)){
d <- sqrt(sum((raw[i,]-center[j,])^2))
rs$d1[i] <- d
}
rs$rank <- orderBy(~-dense_rank(rs$d1))
for (i in 1:nrow(raw)){
d <- sqrt(sum((raw[i,]-center[j,])^2))
rs$d1[i] <- d
}
rs$rank <- dense_rank(rs$d1)
orderBy(~rank,rs)
for (i in 1:nrow(raw)){
d <- sqrt(sum((raw[i,]-center[j,])^2))
rs$d1[i] <- d
}
rs$rank <- row_number(rs$d1)
orderBy(~rank,rs)
emp
colMeans(emp$index)
colMeans(emp)
emp <- emp[,c('index','sal')]
emp
colMeans(emp)
rs <- data.frame(x=raw[,1],y=raw[,2])
rs <- data.frame(x=raw[,1],y=raw[,2])
for (i in 1:nrow(raw)){
d <- sqrt(sum((raw[i,]-center[j,])^2))
rs$d1[i] <- d
}
rs
t(rs)
rowSums(t(rs[3]))
rowSums(t(rs[1]))
rowMeans(t(rs[1]))
rowMenas(t(rs[2]))
rowMeans(t(rs[2]))
center
t(center
t(center)
t(center)
sms_result <- read.csv('sms_results.csv')
head(sms_result)
library(gmodels)
CrossTable(sms_result[,2],sms_result[,1])
CrossTable(sms_result$actual_type,sms_result$predict_type)
head(sms_result)
CrossTable(sms_result$actual_type,sms_result$predict_type)
CrossTable(sms_result$predict_type,sms_result$actual_type)
install.packages('wcd')
library(wcd)
library(wcd)
install.packages('vcd')
library(vcd)
kappa(Table(sms_result$predict_type,sms_result$actual_type))
library(data.table)
kappa(Table(sms_result$predict_type,sms_result$actual_type))
kappa(table(sms_result$predict_type,sms_result$actual_type))
Kappa(table(sms_result$predict_type,sms_result$actual_type))
table(sms_result$predict_type,sms_result$actual_type)
pr_e <- (0.868*0.888)+(0.112*0.132)
pr_e
0.8306+(156/1390)
2*(156/1390)*(152/156)/(0.8306+(156/1390))
install.packages('caret')
install.packages("caret")
library(caret)
sensitivity(sms_result$predict_type,sms_result$actual_type,positive = 'spam')
specificity(sms_result$predict_type,sms_result$actual_type,negative='ham')
sms_result <- read.csv('sms_results.csv',stringsAsFactors = T)
sensitivity(sms_result$predict_type,sms_result$actual_type,positive = 'spam')
specificity(sms_result$predict_type,sms_result$actual_type,negative='ham')
posPredValue(sms_result$predict_type,sms_result$actual_type,positive = 'spam')
sensitivity(sms_result$predict_type,sms_result$actual_type,positive = 'spam')
sensitivity(sms_result$predict_type,sms_result$actual_type,positive = 'spam')
specificity(sms_result$predict_type,sms_result$actual_type,negative = 'ham')
posPredValue(sms_result$predict_type,sms_result$actual_type,positive = 'spam')
sensitivity(sms_result$predict_type,sms_result$actual_type,positive = 'spam')
sensitivity(sms_result$predict_type,sms_result$actual_type,positive = 'spam')
specificity(sms_result$predict_type,sms_result$actual_type,negative = 'ham')
posPredValue(sms_result$predict_type,sms_result$actual_type,positive = 'spam')
sensitivity(sms_result$predict_type,sms_result$actual_type,positive = 'spam')
install.packages('ROCR')
library(ROCR)
head(sms_result)
pred <- prediction(predictions = sms_result$prob_spam,
labels = sms_result$actual_type)
pred
# ROC curves
perf <- performance(pred, measure = "tpr", x.measure = "fpr")
dev.new()
dev.new()
plot(perf, main = "ROC curve for SMS spam filter", col = "blue", lwd = 2)
# add a reference line to the graph
# 대각선 출력
abline(a = 0, b = 1, lwd = 2, lty = 2)
# calculate AUC
perf.auc <- performance(pred, measure = "auc")
str(perf.auc)
unlist(perf.auc@y.values)
CrossTable(sms_result$predict_type,sms_result$actual_type)
precision <- posPredValue(sms_result$predict_type,sms_result$actual_type,positive = 'spam')
recall <- sensitivity(sms_result$predict_type,sms_result$actual_type,positive = 'spam')
Fmeasure <- 2*precision*recall/(precision+recall)
Fmeasure
1-(sqrt(20)/7)
1-(8/3*sqrt(20))
1-(8/(3*sqrt(20)))
1-(20/21)
install.packages("irr")
#install.packages("caret")
library(caret)
credit <- read.csv("credit.csv") # 독일 은행의 채무 불이행자를 예측하기 위한 데이터
nrow(credit)
random_ids <- order(runif(1000)) # 난수 1000개 생성
credit_train <- credit[random_ids[1:500],]  # 훈련 50%
credit_validate <- credit[random_ids[501:750], ] # 검정 25%
credit_test <- credit[random_ids[751:1000], ]  # 테스트 25%
nrow(credit_train)
nrow(credit_validate)
nrow(credit_test)
in_train <- createDataPartition(credit$default, p = 0.75, list = FALSE)
head(in_train)
credit_train <- credit[in_train, ] # 훈련 데이터 구성
credit_test <- credit[-in_train, ] # 테스트 데이터 구성
nrow(credit_train)
nrow(credit_test)
folds <- createFolds(credit$default, k = 10)
str(folds)
credit01_test <- credit[folds$Fold01, ]
credit01_train <- credit[-folds$Fold01, ]
library(caret)
library(C50)
library(irr)
set.seed(123)
folds <- createFolds(credit$default, k = 10)
cv_results <- lapply(folds, function(x) {
credit_train <- credit[-x, ]
credit_test <- credit[x, ]
credit_model <- C5.0(default ~ ., data = credit_train)
credit_pred <- predict(credit_model, credit_test)
credit_actual <- credit_test$default
kappa <- kappa2(data.frame(credit_actual, credit_pred))$value
return(kappa)
})
credit <- read.csv("credit.csv",stringsAsFactors = T) # 독일 은행의 채무 불이행자를 예측하기 위한 데이터
random_ids <- order(runif(1000)) # 난수 1000개 생성
credit_train <- credit[random_ids[1:500],]  # 훈련 50%
credit_validate <- credit[random_ids[501:750], ] # 검정 25%
credit_test <- credit[random_ids[751:1000], ]  # 테스트 25%
in_train <- createDataPartition(credit$default, p = 0.75, list = FALSE)
credit_train <- credit[in_train, ] # 훈련 데이터 구성
credit_test <- credit[-in_train, ] # 테스트 데이터 구성
folds <- createFolds(credit$default, k = 10)
credit01_test <- credit[folds$Fold01, ]
credit01_train <- credit[-folds$Fold01, ]
folds <- createFolds(credit$default, k = 10)
cv_results <- lapply(folds, function(x) {
credit_train <- credit[-x, ]
credit_test <- credit[x, ]
credit_model <- C5.0(default ~ ., data = credit_train)
credit_pred <- predict(credit_model, credit_test)
credit_actual <- credit_test$default
kappa <- kappa2(data.frame(credit_actual, credit_pred))$value
return(kappa)
})
str(cv_results)
############################################# 점심
credit <- read.csv("credit.csv",stringsAsFactors = T)
random_ids <- order(runif(800))
credit_train <- credit[random_ids[1:400],]  # 훈련 50%
credit_validate <- credit[random_ids[401:600], ] # 검정 25%
credit_test <- credit[random_ids[601:800], ]  # 테스트 25%
nrow(credit_train)
nrow(credit_validate)
nrow(credit_test)
in_train <- createDataPartition(credit$default, p = 0.75, list = FALSE)
credit_train <- credit[in_train, ] # 훈련 데이터 구성
credit_test <- credit[-in_train, ] # 테스트 데이터 구성
nrow(credit_train)
nrow(credit_test)
nrow(credit_train)
nrow(credit_validate)
nrow(credit_test)
############################################# 점심
credit <- read.csv("credit.csv",stringsAsFactors = T)
random_ids <- order(runif(800))
credit_train <- credit[random_ids[1:400],]  # 훈련 50%
credit_validate <- credit[random_ids[401:600], ] # 검정 25%
credit_test <- credit[random_ids[601:800], ]  # 테스트 25%
nrow(credit_train)
nrow(credit_validate)
nrow(credit_test)
credit <- credit[random_ids[1:800],]
nrow(credit)
credit_train <- credit[random_ids[1:400],]  # 훈련 50%
credit_validate <- credit[random_ids[401:600], ] # 검정 25%
credit_test <- credit[random_ids[601:800], ]  # 테스트 25%
nrow(credit_train)
nrow(credit_validate)
nrow(credit_test)
in_train <- createDataPartition(credit$default, p = 0.75, list = FALSE)
credit_train <- credit[in_train, ] # 훈련 데이터 구성
credit_test <- credit[-in_train, ] # 테스트 데이터 구성
nrow(credit_train)
nrow(credit_test)
folds <- createFolds(credit$default, k = 10)
str(folds)
credit01_test <- credit[folds$Fold01, ]
credit01_train <- credit[-folds$Fold01, ]
set.seed(123)
folds <- createFolds(credit$default, k = 10)
cv_results <- lapply(folds, function(x) {
credit_train <- credit[-x, ]
credit_test <- credit[x, ]
credit_model <- C5.0(default ~ ., data = credit_train)
credit_pred <- predict(credit_model, credit_test)
credit_actual <- credit_test$default
kappa <- kappa2(data.frame(credit_actual, credit_pred))$value
return(kappa)
})
str(cv_results)
credit <- read.csv("credit.csv",stringsAsFactors = T)
credit_train <- credit[in_train, ] # 훈련 데이터 구성
credit_test <- credit[-in_train, ] # 테스트 데이터 구성
credit <- read.csv("credit.csv",stringsAsFactors = T)
set.seed(123)
random_ids <- order(runif(800))
credit <- credit[random_ids[1:800],]
credit_train <- credit[in_train, ] # 훈련 데이터 구성
credit_test <- credit[-in_train, ] # 테스트 데이터 구성
nrow(credit_train)
nrow(credit_test)
credit <- read.csv("credit.csv",stringsAsFactors = T)
set.seed(123)
random_ids <- order(runif(800))
credit <- credit[random_ids[1:800],]
nrow(credit_train) #601
nrow(credit_test) #199
in_train <- createDataPartition(credit$default, p = 0.75, list = FALSE)
credit_train <- credit[in_train, ] # 훈련 데이터 구성
credit_test <- credit[-in_train, ] # 테스트 데이터 구성
nrow(credit_train) #601
nrow(credit_test) #199
folds <- createFolds(credit$default, k = 10)
cv_results <- lapply(folds, function(x) {
credit_train <- credit[-x, ]
credit_test <- credit[x, ]
credit_model <- C5.0(default ~ ., data = credit_train)
credit_pred <- predict(credit_model, credit_test)
credit_actual <- credit_test$default
kappa <- kappa2(data.frame(credit_actual, credit_pred))$value
return(kappa)
})
str(cv_results)
credit <- read.csv("credit.csv",stringsAsFactors = T)
set.seed(123)
random_ids <- order(runif(800))
credit <- credit[random_ids[1:800],]
in_train <- createDataPartition(credit$default, p = 0.7, list = FALSE)
credit_train <- credit[in_train, ] # 훈련 데이터 구성
credit_test <- credit[-in_train, ] # 테스트 데이터 구성
nrow(credit_train) #601
nrow(credit_test) #199
folds <- createFolds(credit$default, k = 10)
in_train <- createDataPartition(credit$default, p = 0.75, list = FALSE)
credit_train <- credit[in_train, ] # 훈련 데이터 구성
credit_test <- credit[-in_train, ] # 테스트 데이터 구성
nrow(credit_train) #601
nrow(credit_test) #199
folds <- createFolds(credit$default, k = 10)
cv_results <- lapply(folds, function(x) {
credit_train <- credit[-x, ]
credit_test <- credit[x, ]
credit_model <- C5.0(default ~ ., data = credit_train)
credit_pred <- predict(credit_model, credit_test)
credit_actual <- credit_test$default
kappa <- kappa2(data.frame(credit_actual, credit_pred))$value
return(kappa)
})
str(cv_results)
str(cv_results)
cv_results <- lapply(folds, function(x) {
credit_train <- credit[-x, ]
credit_test <- credit[x, ]
credit_model <- C5.0(default ~ ., data = credit_train)
credit_pred <- predict(credit_model, credit_test)
credit_actual <- credit_test$default
kappa <- kappa2(data.frame(credit_actual, credit_pred))$value
return(kappa)
})
str(cv_results)
head(credit$default)
in_train <- createDataPartition(credit$default,times=2, p = 0.8, list = FALSE)
in_train
in_train <- createDataPartition(credit$default,p = 0.8, list = FALSE)
in_train
credit <- read.csv("credit.csv",stringsAsFactors = T)
in_train <- createDataPartition(credit$default,p = 0.8, list = FALSE)
in_train
credit <- read.csv("credit.csv",stringsAsFactors = T)
#set.seed(123)
#random_ids <- order(runif(800))
#credit <- credit[random_ids[1:800],]
in_train <- createDataPartition(credit$default,p = 0.8, list = FALSE)
in_train
credit_train <- credit[in_train, ] # 훈련 데이터 구성
credit_test <- credit[-in_train, ] # 테스트 데이터 구성
nrow(credit_train) #601
nrow(credit_test) #199
folds <- createFolds(credit$default, k = 10)
cv_results <- lapply(folds, function(x) {
credit_train <- credit[-x, ]
credit_test <- credit[x, ]
credit_model <- C5.0(default ~ ., data = credit_train)
credit_pred <- predict(credit_model, credit_test)
credit_actual <- credit_test$default
kappa <- kappa2(data.frame(credit_actual, credit_pred))$value
return(kappa)
})
str(cv_results)
in_train <- createDataPartition(credit$default,p = 0.75, list = FALSE)
credit_train <- credit[in_train, ] # 훈련 데이터 구성
credit_test <- credit[-in_train, ] # 테스트 데이터 구성
nrow(credit_train) #601
nrow(credit_test) #199
credit <- read.csv("credit.csv",stringsAsFactors = T)
in_train <- createDataPartition(credit$default,p = 0.75, list = FALSE)
in_train
credit_train <- credit[in_train, ] # 훈련 데이터 구성
credit_test <- credit[-in_train, ] # 테스트 데이터 구성
nrow(credit_train) #601
nrow(credit_test) #199
folds <- createFolds(credit$default, k = 10)
cv_results <- lapply(folds, function(x) {
credit_train <- credit[-x, ]
credit_test <- credit[x, ]
credit_model <- C5.0(default ~ ., data = credit_train)
credit_pred <- predict(credit_model, credit_test)
credit_actual <- credit_test$default
kappa <- kappa2(data.frame(credit_actual, credit_pred))$value
return(kappa)
})
str(cv_results)
mean(unlist(cv_results))
credit <- read.csv("credit.csv")
set.seed(123)
cv_results <- lapply(folds, function(x) {
credit_train <- credit[-x, ]
credit_test <- credit[x, ]
credit_model <- C5.0(default ~ ., data = credit_train)
credit_pred <- predict(credit_model, credit_test)
credit_actual <- credit_test$default
kappa <- kappa2(data.frame(credit_actual, credit_pred))$value
return(kappa)
})
str(cv_results)
mean(unlist(cv_results))
# 296
credit <- read.csv("credit.csv",stringsAsFactors = T)
in_train <- createDataPartition(credit$default,p = 0.75, list = FALSE)
credit_train <- credit[in_train, ]
credit_test <- credit[-in_train, ]
folds <- createFolds(credit$default, k = 10)
cv_results <- lapply(folds, function(x) {
credit_train <- credit[-x, ]
credit_test <- credit[x, ]
credit_model <- C5.0(default ~ ., data = credit_train)
credit_pred <- predict(credit_model, credit_test)
credit_actual <- credit_test$default
x <- data.frame(credit_actual, credit_pred)
rs <- sum(x$credit_actual==x$credit_pred)/length(x$credit_actual==x$credit_pred)
return(rs)
})
cv_results
str(cv_results)
# 296
credit <- read.csv("credit.csv",stringsAsFactors = T)
set.seed(123)
folds <- createFolds(credit$default, k = 10)
cv_results <- lapply(folds, function(x) {
credit_train <- credit[-x, ]
credit_test <- credit[x, ]
credit_model <- C5.0(default ~ ., data = credit_train)
credit_pred <- predict(credit_model, credit_test)
credit_actual <- credit_test$default
x <- data.frame(credit_actual, credit_pred)
rs <- sum(x$credit_actual==x$credit_pred)/length(x$credit_actual==x$credit_pred)
return(rs)
})
str(cv_results)
# caret 패키지 사용
credit <- read.csv('credit.csv',stringsAsFactors = T)
set.seed(300)
m <- train(default~., data=credit, method='C5.0')
m
p <- predict(m,credit)
table(p,credit$default)
m_test <- train(default~., data=credit, method='C5.0',
metric='kappa',
trControl=ctrl,
truneGrid=grid)
p <- predict(m_test, credit)
p
str(p)
table(p,credit$default)
m_test <- train(default~., data=credit, method='C5.0',
metric='kappa',
trControl=ctrl,
truneGrid=grid)
m <- train(default~., data=credit, method='C5.0',
metric='kappa',
trControl=ctrl,
truneGrid=grid)
m <- train(default~., data=credit,method='C5.0')
ctrl <- trainControl(method='cv',number=10,selectionFunction='oneSE')
grid <- expand.grid(.model='tree',
.trials=c(1,5,10,15,20,25,30,35), # trials를 8개로 제한하겠다
.winnow='FALSE')
p <- predict(m, credit)
table(p,credit$default)
m <- train(default~., data=credit, method='C5.0',
metric='kappa',
trControl=ctrl,
truneGrid=grid)
ret_err <- function(n,err) {
sum <- 0
for(i in floor(n/2):n) {
sum <- sum + choose(n,i) * err^i * (1-err)^(n-i)
}
sum
}
for(j in 1:60) {
err <- ret_err(j , 0.4)
cat(j,'--->',1-err,'\n')
if(1-err >= 0.9) break
}
install.packages('ipred')
install.packages("ipred")
library(ipred)
set.seed(300)
credit <- read.csv('credit.csv',stringsAsFactors = T)
set.seed(300)
mybag <- bagging(default~., data=credit, nbagg=25) # nbagg=25 : 앙상블에 사용되는  bag의 개수
credit_pred <- predict(mybag, credit)
credit_pred <- predict(mybag, credit)
table(credit_pred,credit$default)
prop.table(table(credit_pred==credit$default))
# 299
mybag <- bagging(default~., data=credit, nbagg=50)
credit_pred <- predict(mybag, credit)
table(credit_pred,credit$default)
prop.table(table(credit_pred==credit$default))
install.packages('adabag')
library(adabag)
set.seed(300)
credit <- read.csv('credit.csv',stringsAsFactors = T)
m_adaboost <- boosting(default~., data=credit)
p_adaboost <- predict(m_adaboost, credit)
head(p_adaboost$class)
p_adaboost$confusion
table(p_adaboost$class,credit$default)
mushroom <- read.csv('mushrooms.csv',stringsAsFactors = T)
str(mushroom)
m_adaboost <- boosting(type~., data=mushroom)
p_adaboost <- predict(m_adaboost, mushroom)
table(p_adaboost$class,credit$type)
p_adaboost
table(p_adaboost$class,mushroom$type)
