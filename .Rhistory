naive_fun<-function(){
library(e1071)
flu <- read.csv("flu.csv", header=T, stringsAsFactors=TRUE)
train <- flu[1:nrow(flu),-1]
model <- naiveBayes(train[,1:4], train$flue , laplace=0)
fname <- file.choose()
test <- read.csv(fname, header=T, stringsAsFactor=F )
result <- predict( model, test, type='raw')
print(paste('독감 환자일 확률이',round(result[2]*100,digits=1),'% 입니다.'))
}
x1 <- menu( c('산포도 그래프','히스토그램 그래프','사분위수 그래프', '유방암 진단', '독감 진단') ,
title='숫자를 선택하세요: ' )
switch ( x1,
san1 = {   my_scatter()       },
san2 = {   my_hist()          },
san3 = {   my_box()           },
san4 = {   knn_fun()          },
san5 = {   naive_fun()        }
)
}
my_func()
(-11/16)*log2(11/16)+(-5/16)*log2(5/16)
(-10/16)*log2(10/16)+(-6/16)*log2(6/16)
((-2/3)*log2(2/3)+(-1/3)*log2(1/3))*3/5
skin <- read.csv('skin.csv',head=T)
skin
str(skin)
skin <- read.csv('skin.csv',head=T, stringsAsFactors = T)
str(skin)
head(skin)
install.packages('FSelector')
library(FSelector)
weights <- information.gain(cupon_react~., skin, unit='log2')
print(weights)
weights <- information.gain(cupon_react~gender, skin, unit='log2')
print(weights)
weights <- information.gain(cupon_react~skin[,-1], skin, unit='log2')
weights <- information.gain(cupon_react~., skin, unit='log2')
print(weights)
skin <- read.csv('skin.csv',head=T, stringsAsFactors = T)
head(skin)
weights <- information.gain(cupon_react~., skin, unit='log2')
print(weights)
skin <- read.csv('skin.csv',header=T, stringsAsFactors = T)
weights <- information.gain(cupon_react~., skin, unit='log2')
print(weights)
print(weights)
fat <- read.csv('fatliver2.csv',head=T,stringsAsFactors = T)
fat
str(fat)
rs2 <- information.gain(fatliver~., fat, unit='log2')
rs2 <- information.gain(FATLIVER~., fat, unit='log2')
print(rs)
rs <- information.gain(FATLIVER~., fat, unit='log2')
print(rs)
# 1. 의사결정 패키지인 C50 패키지를 설치한다.
install.packages("C50")
library(C50)
# 2. 백화점 화장품 고객 데이터를 로드하고 shuffle 한다.
skin <- read.csv("skin.csv", header=T )
nrow(skin)
skin_real_test_cust <- skin[30,  ] # 모델 생성 후 정확도를 올린 후 최종적으로 모델이 잘 맞추는지 확인하기 위해 한 건 제외
skin2 <-  skin[ 1:29, ]
nrow(skin2)
skin_real_test_cust
skin2 <- skin2[ , -1] # 고객번호를 제외시킨다.
set.seed(11)
skin2_shuffle <- skin2[sample(nrow(skin2)),    ]  # shuffle 시킴
# 3. 화장품 고객 데이터를 7대 3로 train 과 test 로 나눈다.
train_num <-  round(0.7 * nrow(skin2_shuffle), 0)
skin2_train <- skin2_shuffle[1:train_num,  ]
skin2_test  <- skin2_shuffle[(train_num+1) : nrow(skin2_shuffle), ]
nrow(skin2_train)  # 20
nrow(skin2_test)   #  9
# 4. C50 패키지를 이용해서 분류 모델을 생성한다.
skin_model <- C5.0(skin2_train[  , -6],  skin2_train$cupon_react )
# 4. C50 패키지를 이용해서 분류 모델을 생성한다.
skin_model <- C5.0(skin2_train[  , -6],  skin2_train$cupon_react )
# 2. 백화점 화장품 고객 데이터를 로드하고 shuffle 한다.
skin <- read.csv("skin.csv", header=T,stringsAsFactors = T )
nrow(skin)
skin_real_test_cust <- skin[30,  ] # 모델 생성 후 정확도를 올린 후 최종적으로 모델이 잘 맞추는지 확인하기 위해 한 건 제외
skin2 <-  skin[ 1:29, ]
nrow(skin2)
skin_real_test_cust
skin2 <- skin2[ , -1] # 고객번호를 제외시킨다.
set.seed(11)
skin2_shuffle <- skin2[sample(nrow(skin2)),    ]  # shuffle 시킴
# 3. 화장품 고객 데이터를 7대 3로 train 과 test 로 나눈다.
train_num <-  round(0.7 * nrow(skin2_shuffle), 0)
skin2_train <- skin2_shuffle[1:train_num,  ]
skin2_test  <- skin2_shuffle[(train_num+1) : nrow(skin2_shuffle), ]
nrow(skin2_train)  # 20
nrow(skin2_test)   #  9
# 4. C50 패키지를 이용해서 분류 모델을 생성한다.
skin_model <- C5.0(skin2_train[,-6],  skin2_train$cupon_react )
# 5. 위에서 만든 skin_model 를 이용해서 테스테 데이터의 라벨을 예측하시오!
skin2_result  <- predict( skin_model , skin2_test[  , -6])
# 5. 위에서 만든 skin_model 를 이용해서 테스테 데이터의 라벨을 예측하시오!
skin2_result  <- predict( skin_model , skin2_test[  , -6])
skin2_test
# 4. C50 패키지를 이용해서 분류 모델을 생성한다.
skin_model <- C5.0(skin2_train[,-6],  skin2_train$cupon_react )
# 5. 위에서 만든 skin_model 를 이용해서 테스테 데이터의 라벨을 예측하시오!
skin2_result  <- predict( skin_model , skin2_test[  , -6])
# 4. C50 패키지를 이용해서 분류 모델을 생성한다.
skin_model <- C5.0(skin2_train[,-6],  skin2_train$cupon_react,type='class' )
# 5. 위에서 만든 skin_model 를 이용해서 테스테 데이터의 라벨을 예측하시오!
skin2_result  <- predict( skin_model , skin2_test[  , -6])
# 4. C50 패키지를 이용해서 분류 모델을 생성한다.
skin_model <- C5.0(skin2_train[,-6],  skin2_train$cupon_react )
# 5. 위에서 만든 skin_model 를 이용해서 테스테 데이터의 라벨을 예측하시오!
skin2_result  <- predict( skin_model , skin2_test[  , -6],type='class')
# 5. 위에서 만든 skin_model 를 이용해서 테스테 데이터의 라벨을 예측하시오!
skin2_result  <- predict( skin_model , skin2_test[,-6])
skin <- read.csv("skin.csv", header=T ,stringsAsFactors = TRUE)
str(skin)
nrow(skin)
skin_real_test_cust <- skin[30,  ]  # 나중에 모델 만들고 정확도를 올린후에
# 최종적으로 모델이 잘 맞추는지 확인하려
# 한건 제외 시킨다.
skin2 <-  skin[ 1:29, ]
nrow(skin2)
skin_real_test_cust
skin2 <- skin2[ , -1] # 고객번호를 제외시킨다.
set.seed(11)
skin2_shuffle <- skin2[sample(nrow(skin2)),    ]  # shuffle 시킴
train_num <-  round(0.7 * nrow(skin2_shuffle), 0)
skin2_train <- skin2_shuffle[1:train_num,  ]
skin2_test  <- skin2_shuffle[(train_num+1) : nrow(skin2_shuffle), ]
nrow(skin2_train)  # 20
nrow(skin2_test)   #  9
library(C50)
skin_model <- C5.0(skin2_train[  , -6],  skin2_train$cupon_react )
skin2_result  <- predict( skin_model , skin2_test[  , -6])
skin <- read.csv("skin.csv", head=T ,stringsAsFactors = T)
skin_real_test_cust <- skin[30,  ]  # 나중에 모델 만들고 정확도를 올린후에
# 최종적으로 모델이 잘 맞추는지 확인하려
# 한건 제외 시킨다.
skin2 <-  skin[ 1:29, ]
skin_real_test_cust
skin2 <- skin2[ , -1] # 고객번호를 제외시킨다.
set.seed(11)
skin2_shuffle <- skin2[sample(nrow(skin2)),    ]  # shuffle 시킴
train_num <-  round(0.7 * nrow(skin2_shuffle), 0)
skin2_train <- skin2_shuffle[1:train_num,  ]
skin2_test  <- skin2_shuffle[(train_num+1) : nrow(skin2_shuffle), ]
skin_model <- C5.0(skin2_train[  , -6],  skin2_train$cupon_react )
skin2_result  <- predict( skin_model , skin2_test[  , -6])
library(gmodels)
CrossTable( skin2_test[  , 6],  skin2_result )
skin_model2 <- C5.0(skin2_train[  , -6],  skin2_train$cupon_react,trials=10 )
skin2_result  <- predict( skin_model , skin2_test[  , -6])
CrossTable( skin2_test[  , 6],  skin2_result )
skin2_result  <- predict( skin_model2 , skin2_test[  , -6])
CrossTable( skin2_test[  , 6],  skin2_result )
skin_model2 <- C5.0(skin2_train[  , -6],  skin2_train$cupon_react,trials=10 )
skin2_result  <- predict( skin_model2 , skin2_test[  , -6])
CrossTable( skin2_test[  , 6],  skin2_result )
skin <- read.csv("skin.csv", head=T ,stringsAsFactors = T)
skin_real_test_cust <- skin[30,  ]  # 나중에 모델 만들고 정확도를 올린후에 최종적으로 모델이 잘 맞추는지 확인하려 한건 제외 시킨다.
skin2 <-  skin[ 1:29, ]
skin_real_test_cust
skin2 <- skin2[ , -1] # 고객번호를 제외시킨다.
set.seed(11)
skin2_shuffle <- skin2[sample(nrow(skin2)),    ]  # shuffle 시킴
train_num <-  round(0.7 * nrow(skin2_shuffle), 0)
skin2_train <- skin2_shuffle[1:train_num,  ]
skin2_test  <- skin2_shuffle[(train_num+1) : nrow(skin2_shuffle), ]
library(C50)
skin_model <- C5.0(skin2_train[  , -6],  skin2_train$cupon_react )
skin_model2 <- C5.0(skin2_train[  , -6],  skin2_train$cupon_react,trials=10 )
skin2_result  <- predict( skin_model2 , skin2_test[  , -6])
CrossTable( skin2_test[  , 6],  skin2_result )
skin_model2 <- C5.0(skin2_train[  , -6],  skin2_train$cupon_react,trials=14 )
skin2_result  <- predict( skin_model2 , skin2_test[  , -6])
CrossTable( skin2_test[  , 6],  skin2_result )
skin <- read.csv("skin.csv", head=T ,stringsAsFactors = T)
skin_real_test_cust <- skin[30,  ]  # 나중에 모델 만들고 정확도를 올린후에 최종적으로 모델이 잘 맞추는지 확인하려 한건 제외 시킨다.
skin2 <-  skin[ 1:29, ]
skin_real_test_cust
skin2 <- skin2[ , -1] # 고객번호를 제외시킨다.
set.seed(20)
skin2_shuffle <- skin2[sample(nrow(skin2)),    ]  # shuffle 시킴
train_num <-  round(0.7 * nrow(skin2_shuffle), 0)
skin2_train <- skin2_shuffle[1:train_num,  ]
skin2_test  <- skin2_shuffle[(train_num+1) : nrow(skin2_shuffle), ]
skin_model2 <- C5.0(skin2_train[  , -6],  skin2_train$cupon_react,trials=10 )
skin2_result  <- predict( skin_model2 , skin2_test[  , -6])
CrossTable( skin2_test[  , 6],  skin2_result )
credit <- read.csv("credit.csv",head=T)
str(credit)
credit <- read.csv("credit.csv",head=T,stringsAsFactors = T)
str(credit)
prop.table( table(credit$default)  )
summary( credit$amount)
str(credit)
set.seed(31)
credit_shuffle <-  credit[ sample( nrow(credit) ),  ]
train_num <- round( 0.9 * nrow(credit_shuffle), 0)
credit_train <- credit_shuffle[1:train_num ,  ]
credit_test  <- credit_shuffle[(train_num+1) : nrow(credit_shuffle),  ]
credit_model <- C5.0( credit_train[ ,-17] , credit_train[  , 17] )
credit_result <-  predict( credit_model, credit_test[  , -17] )
CrossTable(  credit_test[   , 17], credit_result )
#                ↑                     ↑
#              실제                   예측
rs <- CrossTable(  credit_test[   , 17], credit_result )
rs
rs[1,1]
credit_model
summary(credit_model)
skin_model
skin_model <- C5.0(skin2_train[  , -6],  skin2_train$cupon_react )
skin_model
summary(skin_model)
((-2/3)*log2(2/3)+(-1/3)*log2(1/3))*3/5
install.packages('caret')
install.packages('rpart')
install.packages("rpart")
install.packages('rpart.plot')
credit = read.csv('credit.csv',header=T,stringsAsFactors = T)
library(caret)
set.seed(5)
intrain = createDataPartition(credit$default,p=0.9,list=F)
credit_train = credit[intrain,]
credit_test = credit[-intrain,]
nrow(credit_train) # 900
nrow(credit_test) # 100
library(C50)
credit_model = C5.0(default~.,data=credit_train,trials=24) # 24 : 0.87
credit_result = predict(credit_model,credit_test[,-17])
library(gmodels)
x = CrossTable(credit_test[,17],credit_result)
library(rpart)
library(rpart.plot)
rpartmod = rpart(default~., data=credit_train, method='class')
rpart.plot(rpartmod)
x$prop.tbl[1]+x$prop.tbl[4] # 0.87
dev.new()
rpart.plot(rpartmod)
savePlot('dcs_tree.png', type='png')
getwd()
# 1. 버섯 데이터를 R 로 로드한다.
mushroom <- read.csv("mushrooms.csv",head=T, stringsAsFactors=T)
str(mushroom)
head(mushroom)
set.seed(11)
dim(mushroom)
train_cnt <- round( 0.75 * dim(mushroom)[1])
length(train_cnt)
nrow(train_cnt)
train_cnt
train_index
mushroom_train <- mushroom[train_index,  ]
mushroom_test  <- mushroom[-train_index, ]
install.packages("OneR")
library(OneR)
model1 <- OneR(type~. ,  data=mushroom_train)
model1
summary(model1)
# 4. 위에서 생성한 모델을 가지고 테스트 데이터로 결과를 확인한다.
result1 <- predict( model1, mushroom_test[   , -1] )
library(gmodels)
CrossTable( mushroom_test[ , 1],  result1)
install.packages("gmodels")
library(gmodels)
CrossTable( mushroom_test[ , 1],  result1)
buy <- data.frame(
cust_name=c('SCOTT','SMITH','ALLEN','JONES','WARD'),
card_yn=c('Y','Y','N','Y','Y'),
intro_yn=c('Y','Y','N','N','Y'),
before_buy_yn=c('Y','Y','Y','N','Y'),
buy_yn=c('Y','Y','N','Y','Y') )
buy
prop.table( table(buy$buy_yn)  )
str(buy)
library(C50)
buy <- buy[,-1]
buy
buy_model <- C5.0( buy[-4] , buy[  , 4] )
buy <- data.frame(
cust_name=c('SCOTT','SMITH','ALLEN','JONES','WARD'),
card_yn=as.factor(c('Y','Y','N','Y','Y')),
intro_yn=as.factor(c('Y','Y','N','N','Y')),
before_buy_yn=as.factor(c('Y','Y','Y','N','Y')),
buy_yn=as.factor(c('Y','Y','N','Y','Y')) )
buy <- buy[,-1]
buy_model <- C5.0( buy[-4] , buy[  , 4] )
buy_model
summary(buy_model)
skin <- read.csv('skin.csv',header=T, stringsAsFactors = T)
str(skin)
head(skin)
install.packages('FSelector')
library(FSelector)
weights <- information.gain(cupon_react~., skin, unit='log2')
print(weights)
fat <- read.csv('fatliver2.csv',head=T,stringsAsFactors = T)
str(fat)
rs <- information.gain(FATLIVER~., fat, unit='log2')
print(rs)
install.packages("C50")
library(C50)
skin <- read.csv("skin.csv", head=T ,stringsAsFactors = T)
skin_real_test_cust <- skin[30,  ]  # 나중에 모델 만들고 정확도를 올린후에 최종적으로 모델이 잘 맞추는지 확인하려 한건 제외 시킨다.
skin2 <-  skin[ 1:29, ]
skin_real_test_cust
skin2 <- skin2[ , -1] # 고객번호를 제외시킨다.
set.seed(20)
skin2_shuffle <- skin2[sample(nrow(skin2)),    ]  # shuffle 시킴
train_num <-  round(0.7 * nrow(skin2_shuffle), 0)
skin2_train <- skin2_shuffle[1:train_num,  ]
skin2_test  <- skin2_shuffle[(train_num+1) : nrow(skin2_shuffle), ]
library(C50)
skin_model <- C5.0(skin2_train[  , -6],  skin2_train$cupon_react )
install.packages("C50")
skin <- read.csv("skin.csv", head=T ,stringsAsFactors = T)
skin_real_test_cust <- skin[30,  ]  # 나중에 모델 만들고 정확도를 올린후에 최종적으로 모델이 잘 맞추는지 확인하려 한건 제외 시킨다.
skin2 <-  skin[ 1:29, ]
skin_real_test_cust
skin2 <- skin2[ , -1] # 고객번호를 제외시킨다.
set.seed(20)
skin2_shuffle <- skin2[sample(nrow(skin2)),    ]  # shuffle 시킴
train_num <-  round(0.7 * nrow(skin2_shuffle), 0)
skin2_train <- skin2_shuffle[1:train_num,  ]
skin2_test  <- skin2_shuffle[(train_num+1) : nrow(skin2_shuffle), ]
library(C50)
skin_model <- C5.0(skin2_train[  , -6],  skin2_train$cupon_react )
skin_model
summary(skin_model)
skin2_result  <- predict( skin_model , skin2_test[  , -6])
CrossTable( skin2_test[  , 6],  skin2_result )
skin_model2 <- C5.0(skin2_train[  , -6],  skin2_train$cupon_react,trials=10 )
skin2_result  <- predict( skin_model2 , skin2_test[  , -6])
CrossTable( skin2_test[  , 6],  skin2_result )
print(rs)
buy
buy <- data.frame(
cust_name=c('SCOTT','SMITH','ALLEN','JONES','WARD'),
card_yn=c('Y','Y','N','Y','Y'),
intro_yn=c('Y','Y','N','N','Y'),
before_buy_yn=c('Y','Y','Y','N','Y'),
buy_yn=c('Y','Y','N','Y','Y') )
rs <- information.gain(buy_yn~., buy, unit='log2')
print(rs)
# 1. 데이터를 로드한다.
reg <- read.table("regression.txt", header=T)
reg
#  2. 데이터를 시각화 한다.
attach(reg)
plot(growth~tannin, data = reg, pch=21, col='blue', bg='red')
# 3. 회귀분석을 해서 회귀 계수인 기울기와 절편을 구하시오 !
m <- lm( growth ~ tannin, data=reg)
#             ↑     ↑           ↑
#       회귀함수  종속변수  독립변수
m
# 4. 위의 산포도 그래프에 회귀 직선을 그린다.
abline( m ,  col='red')
# 5. 그래프 제목을 회귀 직선의 방정식으로 출력되게한다.
title(paste( '성장률=', round(m$coefficients[2], 4), "* 탄닌 + ", round(m$coefficients[1], 4)))
# 6. 위의 그래프에 잔차를 그린다.
y_hat <- predict( m, tannin=tannin)
y_hat
reg
y_hat
join <- function(i){
lines( c(tannin[i], tannin[i]), c( growth[i],y_hat[i]), col="green")
}
sapply(1:9, join)
plot(growth~tannin, data = reg, pch=21, col='blue', bg='red')
# 3. 회귀분석을 해서 회귀 계수인 기울기와 절편을 구하시오 !
m <- lm( growth ~ tannin, data=reg)
#    ↑       ↑        ↑
#  reg함수  종속    독립
m
# 4. 위의 산포도 그래프에 회귀 직선을 그린다.
abline( m ,  col='red')
sapply(1:9, join) #
# 1. 데이터를 로드한다.
adv <- read.csv("simple_hg.csv", header=T)
adv
str(adv)
#  2. 데이터를 시각화 한다.
attach(adv)
plot(input~cost, data = adv, pch=21, col='blue', bg='red')
# 3. 회귀분석을 해서 회귀 계수인 기울기와 절편을 구하시오 !
adv_m <- lm( input ~ cost, data=adv)
#    ↑       ↑        ↑
#  reg함수  종속    독립
adv_m # 회귀계수-> 직선의 기울기
# 4. 위의 산포도 그래프에 회귀 직선을 그린다.
abline( m ,  col='red')
# 4. 위의 산포도 그래프에 회귀 직선을 그린다.
abline( adv_m ,  col='red')
# 5. 그래프 제목을 회귀 직선의 방정식으로 출력되게한다.
title(paste( '증가율=', round(adv_m$coefficients[2], 4), "*광고비+ ", round(m$coefficients[1], 4)))
# 5. 그래프 제목을 회귀 직선의 방정식으로 출력되게한다.
title(paste( '증가율=', round(adv_m$coefficients[2], 4), "*광고비+ ", round(adv_m$coefficients[1], 4)))
#    ↑       ↑        ↑
#  reg함수  종속    독립
adv_m # 회귀계수-> 직선의 기울기
# 4. 위의 산포도 그래프에 회귀 직선을 그린다.
abline( adv_m ,  col='red')
# 5. 그래프 제목을 회귀 직선의 방정식으로 출력되게한다.
title(paste( '증가율=', round(adv_m$coefficients[2], 4), "*광고비+ ", round(adv_m$coefficients[1], 4)))
plot(input~cost, data = adv, pch=21, col='blue', bg='red')
# 4. 위의 산포도 그래프에 회귀 직선을 그린다.
abline( adv_m ,  col='red')
# 5. 그래프 제목을 회귀 직선의 방정식으로 출력되게한다.
title(paste( '증가율=', round(adv_m$coefficients[2], 4), "*광고비+ ", round(adv_m$coefficients[1], 4)))
# 6. 위의 그래프에 잔차를 그린다.
y_hat <- predict( adv_m, cost=cost) #
y_hat
join <- function(i){
lines( c(cost[i], cost[i]), c( input[i],y_hat[i]), col="green")
}
sapply(1:9, join) #
sapply(1:nrow(adv), join) #
# 1. 데이터를 로드한다.
launch <- read.csv("challenger.csv")
launch
# 2. lm 회귀함수로 기울기와 절편을 구한다.
attach(launch)
plot( distress_ct ~ temperature,  data=launch,  col="red", bg="red", pch=21)
m <- lm( distress_ct ~ temperature, launch)
abline( m ,  col="blue")
names(launch)
plot(distress_ct ~ temperature, data=launch)
m <- lm(distress_ct  ~  temperature, launch)
plot( distress_ct ~ temperature,  data=launch,  col="red", bg="red", pch=21)
m <- lm( distress_ct ~ temperature, launch)
abline( m ,  col="blue")
abline(m, col='red')
abline( m ,  col="blue")
title(paste('파손수=', round(m$coefficients[1], 4), "* 온도 + ",
round(m$coefficients[2], 4)))
cor(launch$temperature,launch$distress_ct)
k_index <- read.csv("K_index.csv", header=T,  stringsAsFactors=F)
s_stock <- read.csv("S_stock.csv", header=T, stringsAsFactors=F)
h_stock <- read.csv("H_stock.csv", header=T,  stringsAsFactors=F)
all_data <- merge(merge(k_index,s_stock), h_stock)
head(all_data)
attach(all_data)
#             y축(삼성 수익율 등락 비율)
#               ↓
plot(k_rate, s_rate, col="blue")
plot(k_rate, h_rate, col="blue")
par(mfrow=c(1,3))
#             y축(삼성 수익율 등락 비율)
#               ↓
plot(k_rate, s_rate, col="blue")
plot(k_rate, h_rate, col="blue")
model_s <- lm( s_rate ~ k_rate, data=all_data)
abline( model_s,  col="red")
plot(k_rate, h_rate, col="blue")
model_h <- lm( h_rate ~ k_rate, data=all_data)
abline( model_h,  col="red")
graphics.off()
par(mfrow=c(1,2), new=T)
par(mar=c(2,2,2,2) )
plot(k_rate, s_rate, col="blue")
model_s <- lm( s_rate ~ k_rate, data=all_data)
abline( model_s,  col="red")
plot(k_rate, h_rate, col="blue")
model_h <- lm( h_rate ~ k_rate, data=all_data)
abline( model_h,  col="red")
all_data
#             y축(삼성 수익율 등락 비율)
#               ↓
plot(s_rate, k_rate, col="blue")
plot(h_rate, k_rate, col="blue")
model_s <- lm( k_rate ~ s_rate, data=all_data)
abline( model_s,  col="red")
#plot(k_rate, s_rate, col="blue")
plot(s_rate, k_rate, col="blue") # s to kos
model_s <- lm( k_rate ~ s_rate, data=all_data) # s affect to kos
abline( model_s,  col="red")
#plot(k_rate, h_rate, col="blue")
plot(h_rate, k_rate, col="blue") # h to kos
model_h <- lm( k_rate ~ h_rate, data=all_data) # h aff to kos
abline( model_h,  col="red")
cor(all_data$k_rate,all_data$s_rate)
cor(all_data$k_rate, all_data$s_rate)
cov(all_data$k_rate, all_data$s_rate)
all_data
head(all_data)
attach(all_data)
cov(all_data$k_rate, all_data$s_rate)
install.packages('shiny')
library(shiny)
runExample("01_hello")
runExample("03_reactivity")
ui <- fluidPage(
fluidRow(
column(5, "test")
)
)
server <- function(input, output, session) {
}
shinyApp(ui, server)
shiny::runGitHub('GDAA', 'hyunyulhenry')
install.packages('tibble')
install.packages("tibble")
install.packages('tibble')
install.packages("tibble")
shiny::runGitHub('GDAA', 'hyunyulhenry')
install.packages('tibble')
shiny::runGitHub('GDAA', 'hyunyulhenry')
library(tibble)
mj <- read.csv('mw_job.csv',head=T)
View(mj)
